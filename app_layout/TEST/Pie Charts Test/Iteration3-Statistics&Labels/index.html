<!DOCTYPE html>
<meta charset="utf-8">
<style>

.arc text {
	font: 10px sans-serif;
	text-anchor: middle;
}

.arc path {
	stroke: #fff;
}

</style>
<body>
	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script>
	var url = "http://localhost/";

	var margin = {top: 50, right: 50, bottom: 50, left: 50};

	var width = 1000 - margin.left - margin.right;
	var height = 900 - margin.top - margin.bottom;

	var innerRadius = Math.min(width, height) / 4;
	var outerRadius = Math.min(width, height) / 3;

	// ---- label Text STUFF
	var labelFontSize = "14px"
	// -------------------
	// ---- Inner Text STUFF
	var units = "objects";

	var numDecimalPlaces = 3;

	var innerFontSize = "35px";

	var labelXOffset = "0em";
	var labelYOffset = "-.5em";

	var topXOffset = "0em";
	var topYOffset = ".5em";

	var bottomXOffset = "0em";
	var bottomYOffset = "1.5em";
	// --------------------
	// --- linelabels STUFF
	var letterLineLength = 11;
	var lineToLabelEnd = outerRadius * .2;
	var lineToLabelStart = outerRadius;

	// --------------------
	var color = d3.scaleOrdinal()
	.range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);

	var arc = d3.arc()
	.outerRadius(outerRadius)
	.innerRadius(innerRadius);

	var arcOver = d3.arc()
	.innerRadius(innerRadius)
	.outerRadius(outerRadius+5);

	var labelArc = d3.arc()
	.outerRadius(outerRadius)
	.innerRadius(innerRadius);

	var pie = d3.pie()
	.sort(null)
	.value(function(d) { return d.count; });

	var svg = d3.select("body").append("svg")
	.attr("width", width)
	.attr("height", height)
	.append("g")
	.attr("transform", "translate(" + width / 2  + "," + height / 2 + ")");

	function type(d)
	{
		d.count = +d.count;
		return d;
	}

	var total = 0;
	d3.csv("data.csv", type, function(error, data)
	{
		if (error)
		{
			throw error;
		}

		data = parseData(data);
		g = svg.selectAll(".arc")
		.data(pie(data))
		.enter().append("g")
		.attr("class", "arc");

		createTextBoxes(g);

		g.append("path")
		.attr("d", arc)
		.style("fill", function(d) { return color(d.data.name); })
		.on("mouseenter", function(d) {
			innerLabelEnter(d);
			d3.select(this)
				.transition()
			    .duration(100)
				.attr("d", arcOver);

		})
		.on("mouseout", function(d) {
			innerLabelExit(d);
			d3.select(this)
				.transition()
				.duration(100)
				.attr("d", arc);
		});
		// text
		g.append("text")
		.attr("text-anchor", "middle")
		.attr("x", function(d) {
			var a = calculateAngle(d);
			var quadrant = Math.cos(a) * (outerRadius + lineToLabelEnd);
			return quadrantCalculator(quadrant, letterLineLength*d.data.name.length/2);
		})
		.attr("y", function(d) {
			var a = calculateAngle(d);
			return Math.sin(a) * (outerRadius + lineToLabelEnd) - 5;

		})
		.style("font-size", labelFontSize)
		.text(function(d) { return d.data.name; });

		// pie2labelline
		g.append("line")
		.attr("x1", function(d) {
			var a = calculateAngle(d);
			return Math.cos(a) * (lineToLabelStart);
		})
		.attr("y1", function(d) {
			var a = calculateAngle(d);
			return Math.sin(a) * (lineToLabelStart);
		})
		.attr("x2", function(d) {
			var a = calculateAngle(d);
			return Math.cos(a) * (outerRadius + lineToLabelEnd);
		})
		.attr("y2", function(d) {
			var a = calculateAngle(d);
			return Math.sin(a) * (outerRadius + lineToLabelEnd);
		})
		.attr("stroke-width", 2)
        .attr("stroke", "black");
		// label underline
		g.append("line")
		.attr("x1", function(d) {
			var a = calculateAngle(d);
			return Math.cos(a) * (outerRadius + lineToLabelEnd);
		})
		.attr("y1", function(d) {
			var a = calculateAngle(d);
			return Math.sin(a) * (outerRadius + lineToLabelEnd);
		})
		.attr("x2", function(d) {
			var a = calculateAngle(d);
			var quadrant = Math.cos(a) * (outerRadius + lineToLabelEnd);
			return quadrantCalculator(quadrant, letterLineLength*d.data.name.length);
		})
		.attr("y2", function(d) {
			var a = calculateAngle(d);
			return Math.sin(a) * (outerRadius + lineToLabelEnd);
		})
		.attr("stroke-width", 2)
		.attr("stroke", "black");

		svg.attr("transform", "translate(" + (width/ 2 + margin.left) + "," + (height/ 2 + margin.top) + ")");
		setTextBoxes(data);
	});
	function createTextBoxes(g)
	{
		text = g.append("text")
			.attr("transform", 0)
			.attr("dx", topXOffset)
			.attr("dy", topYOffset)
			.style("text-anchor", "middle")
			.style("fill", "black")
			.style("font-size", innerFontSize)
			.attr("class", "on")
			.text(" ");

		bottomText = g.append("text")
		.attr("dx", bottomXOffset)
		.attr("dy", bottomYOffset)
		.style("text-anchor", "middle")
		.style("fill", "black")
		.style("font-size", innerFontSize)
		.attr("class", "on")
		.text(" ");

		labelText = g.append("text")
		.attr("dx", labelXOffset)
		.attr("dy", labelYOffset)
		.style("text-anchor", "middle")
		.style("fill", "black")
		.style("font-size", innerFontSize)
		.attr("class", "on")
		.text(" ");
	}
	function setTextBoxes(data)
	{
		text.text(total + " " + units);
	}
	function quadrantCalculator(quadrant, offset)
	{
		if (quadrant > 0)
		{
			return quadrant + offset;
		}
		else
		{
			return quadrant - offset;
		}
	}
	function calculateAngle(data)
	{
		return data.startAngle + (data.endAngle - data.startAngle)/2 - Math.PI/2;
	}
	function innerLabelEnter(d)
	{
		text.text(d.data.count + "/" + total + " " + units);
		bottomText.text(((d.data.count/total)*100).toFixed(numDecimalPlaces) + "%");
		labelText.text(d.data.name);
	}
	function innerLabelExit(d)
	{
		text.text(total + " " + units);
		bottomText.text("");
		labelText.text("");
	}
	function parseData(data)
	{
		var stripped = convertToArray(data);
		var compressed = compressArray(stripped);
		var parsedData = customFilterData(compressed);
		return parsedData;

	}
	function convertToArray(original)
	{
		var result = [];
		for(i = 0; i < original.length; i++)
		{
			result.push(original[i].name);
		}
		return result;
	}
	function compressArray(original)
	{

		var compressed = [];
		// make a copy of the input array
		var copy = original.slice(0);

		// first loop goes over every element
		for (var i = 0; i < original.length; i++) {

			var myCount = 0;
			// loop over every element in the copy and see if it's the same
			for (var w = 0; w < copy.length; w++) {
				if (original[i] == copy[w]) {
					// increase amount of times duplicate is found
					myCount++;
					// sets item to undefined
					delete copy[w];
				}
			}

			if (myCount > 0) {
				var a = new Object();
				a.name = original[i];
				a.count = myCount;
				total += myCount;
				compressed.push(a);
			}
		}

		return compressed;
	}
	function customFilterData(data)
	{
		// Custom data filters go here.
		return data;
	}
	</script>
