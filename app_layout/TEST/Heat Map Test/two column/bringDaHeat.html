<!DOCTYPE html>
<meta charset="utf-8">
<style>

text {
	font: 10px sans-serif;
	text-anchor: middle;
}

</style>
<svg width="899" height="900"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
var circleInView = {"darkblue": true, "blue": true, "seagreen": true, "Turquoise": true, "SpringGreen": true, "greenyellow": true, "yellow": true,  "orange": true, "orangered":true, "red": true};
var circleColors = ["darkblue", "blue", "seagreen", "Turquoise", "SpringGreen", "greenyellow", "yellow", "orange", "orangered", "red"];
var textColors = ["white", "white", "black", "black", "black", "black", "black", "black", "black", "black"];
var distro = ["0 - 10", "10 - 20", "20 - 30", "30 - 40", "40 - 50", "50 - 60", "60 - 70", "70 - 80", "80 - 90", "90 - 100"];
var svg = d3.select("svg");
var width = +svg.attr("width");
var height = +svg.attr("height");
var bubblePadding = 3;
var format = d3.format(",d");
var legendTileSize = 50;

var infoBubblePadding = 15;
var infoBubbleFontSize = "10px";
var legendXTextPadding = -5; // Negative shifts text to the left.
var r = 75;
var offset = 150;
var x = r + 1;
var y = height * .8;
function addCircle(d)
{
	svg.append("circle")
		.attr("r", r)
		.style("fill", grabCicleColor(d.value))
		.style("stroke", "black")
		.style("stroke-width", 2)
		.attr("transform", function(d) {
			return "translate(" + r + "," + y + ")";
		})
		.attr("class", "bubbleCircle");

	svg.append("circle")
		.attr("r", 10)
		.style("fill", "red")
		.style("stroke", "black")
		.style("stroke-width", 2)
		.attr("transform", function(d) {
			return "translate(" + r + "," + (y + r + 20) + ")";
		})
		.attr("class", "bubbleCircle")
		.on("click", function(d) {
					var x = d3.select(this)["_groups"][0][0]["transform"]["baseVal"][0]["matrix"]["e"];
					console.log(x);
					moveCircle(-offset, x);
					moveText(-offset, x);
				});
	svg.append("text")
		.attr("x", x)
		.attr("y", y)
		.attr("dy", - infoBubblePadding)
		.attr("width", legendTileSize)
		.attr("height", legendTileSize)
		.style("text-anchor", "middle")
		.style("font-size", infoBubbleFontSize)
		.text(d.class)
		.attr("class", "bubbleText");

	svg.append("text")
		.attr("x", x)
		.attr("y", y)
		.attr("dy", infoBubblePadding)
		.attr("width", legendTileSize)
		.attr("height", legendTileSize)
		.style("text-anchor", "middle")
		.style("font-size", infoBubbleFontSize)
		.text(d.value)
		.attr("class", "bubbleText");
}
function moveCircle(offset, xCord)
{
	d3.selectAll(".bubbleCircle")
	.transition()
  	.duration(50)
	.attr("transform", function(d) {
		var x = d3.select(this)["_groups"][0][0]["transform"]["baseVal"][0]["matrix"]["e"];
		var y = d3.select(this)["_groups"][0][0]["transform"]["baseVal"][0]["matrix"]["f"];
		if (x > xCord)
		{
			var y = d3.select(this)["_groups"][0][0]["transform"]["baseVal"][0]["matrix"]["f"];
			return "translate(" + (x + 2*offset) + "," + y + ")";
		}
		else if (x < xCord)
		{
			return "translate(" + x + "," + y + ")";
		}
		else
		{
			return "translate(-200,9001)";
		}

	});
}
function moveText(offset, xCord)
{
	d3.selectAll(".bubbleText")
	.transition()
	.duration(50)
	.attr("y", function (d) {
		var x = d3.select(this)["_groups"][0][0]["x"]["baseVal"][0]["value"];
		var y = d3.select(this)["_groups"][0][0]["y"]["baseVal"][0]["value"];
		if (x != xCord)
		{
			return y;
		}
		else
		{
			return 9001;
		}
	})
	.attr("x", function (d) {
		var x = d3.select(this)["_groups"][0][0]["x"]["baseVal"][0]["value"];
		if (x > xCord)
		{
			x = x + 2*offset;
			return x;
		}
		else if (x < xCord)
		{
			return x;
		}
		else
		{
			return -200;
		}
	});
}
function grabClassColor(number)
{
	var divideColor = d3.scaleLinear().domain([minColor, maxColor+1]).range([0, 1]);
	var index = Math.floor(divideColor(number) * 10);
	return circleColors[index];
}
function grabTextColor(number)
{
	var divideColor = d3.scaleLinear().domain([minColor, maxColor]).range([0, 1]);
	var pickColor = d3.scaleLinear().domain([0, .1, .2, .3, .4, .5, .6, .7, .8, .9]).range(textColors);
	var color = divideColor(number);
	return pickColor(color);
}
function grabCicleColor(number)
{
	var divideColor = d3.scaleLinear().domain([minColor, maxColor]).range([0, 1]);
	var pickColor = d3.scaleLinear().domain([0, .1, .2, .3, .4, .5, .6, .7, .8, .9]).range(circleColors);
	var color = divideColor(number);
	return pickColor(color);
}
var pack = d3.pack()
.size([width, height*.8])
.padding(bubblePadding);
var maxColor = 0;
var minColor = 9999999999999;
d3.csv("heatmap.csv", function(d) {
	d.value = +d.value;
	if (d.value > 1)
	{
		if (d.value < minColor)
		{
			minColor = d.value;
		}
		if (d.value > maxColor)
		{
			maxColor = d.value;
		}
		return d;
	}
}, function(error, classes)
	{
		if (error)
		{
			throw error;
	 	}

		var root = d3.hierarchy({children: classes})
		.sum(function(d) { return d.value; })
		.each(function(d) {
			if (id = d.data.id) {
				var id, i = id.lastIndexOf(".");
				d.id = id;
				d.package = id.slice(0, i);
				d.class = id.slice(i + 1);
			}
		});

		var node = svg.selectAll(".node")
		.data(pack(root).leaves())
		.enter().append("g")
		.attr("class", "node")
		.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

		node.append("circle")
		.attr("id", function(d) { return d.id; })
		.attr("r", function(d) { return d.r; })
		.attr("class", function(d) { return grabClassColor(d.value); })
		.style("fill", function(d) { return grabCicleColor(d.value); })
		.on("click", function(d) {
			moveCircle(offset, 0);
			moveText(offset, 0);
			addCircle(d);
		})
		.on("mouseover", function(d) {
		  d3.select(this).attr("r", d.r + bubblePadding)
		  .style("stroke", "black")
		  .style("stroke-width", 2);
		})
		.on("mouseout", function(d) {
		  d3.select(this).attr("r", d.r)
		  .style("stroke-width", 0);
		});

		node.append("clipPath")
		.attr("id", function(d) { return "clip-" + d.id; })
		.append("use")
		.attr("xlink:href", function(d) { return "#" + d.id; });


		node.append("title")
		.text(function(d) { return d.id + "\n" + format(d.value); });
		createColorLegend();
	});
	function toggleColor(data, color)
	{
		console.log(color);
		subColor = color.substring(1);
		console.log(subColor);
		circleInView[subColor] = !circleInView[subColor];
		d3.selectAll(color)
		.attr("transform", function(d) {

			if (circleInView[subColor])
			{
				return "translate(" + 0 + ")";
			}
			else
			{
				return "translate(" + 10000 + ")";
			}

		})
		.transition()
		.duration(0);
	}
	function createColorLegend()
	{
		for(i = 0; i < circleColors.length; i++)
		{
			var offset = 20;
			// Colored rectangles for legend
			svg.append("rect")
			.attr("x", width - legendTileSize)
			.attr("y", legendTileSize * i)
			.attr("width", legendTileSize)
			.attr("height", legendTileSize)
			.style("fill", circleColors[i])
			.on("click", function(d) {
				var color = "." + d3.select(this)["_groups"][0][0]["style"]["fill"];
				toggleColor(d, color);
			})
			// Text labels for the colored rectangles.
			svg.append("text")
			.attr("x", width - legendTileSize + legendXTextPadding)
			.attr("y", (legendTileSize * i) + legendTileSize/2)
			.attr("dy", ".5em")
			.attr("width", legendTileSize)
			.attr("height", legendTileSize)
			.style("text-anchor", "end")
			.text(distro[i] + "%");
		}
	}

</script>
